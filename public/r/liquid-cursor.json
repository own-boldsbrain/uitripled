{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "liquid-cursor",
  "type": "registry:ui",
  "title": "Cursor Líquido",
  "description": "Um efeito de cursor líquido que mistura cores no movimento",
  "dependencies": [
    "framer-motion",
    "react"
  ],
  "files": [
    {
      "path": "components/liquid-cursor.tsx",
      "content": "\"use client\";\r\n\r\nimport { useEffect, useRef } from \"react\";\r\n\r\ninterface Point {\r\n  x: number;\r\n  y: number;\r\n  vx: number;\r\n  vy: number;\r\n  life: number;\r\n  maxLife: number;\r\n  radius: number;\r\n  color: string;\r\n}\r\n\r\nconst COLORS = [\r\n  \"#FF0080\", // Pink\r\n  \"#7928CA\", // Purple\r\n  \"#0070F3\", // Blue\r\n  \"#00DFD8\", // Cyan\r\n  \"#FF4D4D\", // Red\r\n  \"#FFD700\", // Gold\r\n];\r\n\r\nexport const LiquidCursor = () => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const pointsRef = useRef<Point[]>([]);\r\n  const mouseRef = useRef({ x: 0, y: 0, lastX: 0, lastY: 0, moved: false });\r\n  const rafRef = useRef<number | null>(null);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) return;\r\n\r\n    const resize = () => {\r\n      canvas.width = window.innerWidth;\r\n      canvas.height = window.innerHeight;\r\n    };\r\n    window.addEventListener(\"resize\", resize);\r\n    resize();\r\n\r\n    const handleMouseMove = (e: MouseEvent) => {\r\n      mouseRef.current.x = e.clientX;\r\n      mouseRef.current.y = e.clientY;\r\n      mouseRef.current.moved = true;\r\n    };\r\n    window.addEventListener(\"mousemove\", handleMouseMove);\r\n\r\n    const addPoint = (x: number, y: number) => {\r\n      const angle = Math.random() * Math.PI * 2;\r\n      const speed = Math.random() * 0.5;\r\n      const color = COLORS[Math.floor(Math.random() * COLORS.length)];\r\n\r\n      pointsRef.current.push({\r\n        x,\r\n        y,\r\n        vx: Math.cos(angle) * speed,\r\n        vy: Math.sin(angle) * speed,\r\n        life: 1,\r\n        maxLife: 1,\r\n        radius: Math.random() * 20 + 10, // Random radius between 10 and 30\r\n        color,\r\n      });\r\n    };\r\n\r\n    const animate = () => {\r\n      // Clear with a slight fade for trails, or full clear\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n      // Add new points if mouse moved\r\n      if (mouseRef.current.moved) {\r\n        const dist = Math.hypot(\r\n          mouseRef.current.x - mouseRef.current.lastX,\r\n          mouseRef.current.y - mouseRef.current.lastY\r\n        );\r\n\r\n        // Interpolate points for smooth lines\r\n        if (dist > 0) {\r\n          const steps = Math.min(dist, 20); // Limit steps to avoid lag\r\n          for (let i = 0; i < steps; i+=2) {\r\n             const t = i / steps;\r\n             const x = mouseRef.current.lastX + (mouseRef.current.x - mouseRef.current.lastX) * t;\r\n             const y = mouseRef.current.lastY + (mouseRef.current.y - mouseRef.current.lastY) * t;\r\n             // Only add points occasionally to avoid overcrowding\r\n             if (Math.random() > 0.5) addPoint(x, y);\r\n          }\r\n        }\r\n\r\n        mouseRef.current.lastX = mouseRef.current.x;\r\n        mouseRef.current.lastY = mouseRef.current.y;\r\n        mouseRef.current.moved = false; // Reset moved flag until next event\r\n      } else {\r\n         // If mouse stopped, we update last position to current to be safe\r\n         mouseRef.current.lastX = mouseRef.current.x;\r\n         mouseRef.current.lastY = mouseRef.current.y;\r\n      }\r\n\r\n      // Update and draw points\r\n      for (let i = pointsRef.current.length - 1; i >= 0; i--) {\r\n        const p = pointsRef.current[i];\r\n\r\n        p.life -= 0.01; // Decay rate\r\n        p.x += p.vx;\r\n        p.y += p.vy;\r\n        p.radius *= 0.99; // Shrink slightly\r\n\r\n        if (p.life <= 0 || p.radius < 0.5) {\r\n          pointsRef.current.splice(i, 1);\r\n          continue;\r\n        }\r\n\r\n        ctx.beginPath();\r\n        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);\r\n        ctx.fillStyle = p.color;\r\n        // Use globalAlpha for fading\r\n        ctx.globalAlpha = p.life;\r\n        ctx.fill();\r\n        ctx.globalAlpha = 1;\r\n      }\r\n\r\n      rafRef.current = requestAnimationFrame(animate);\r\n    };\r\n\r\n    animate();\r\n\r\n    return () => {\r\n      window.removeEventListener(\"resize\", resize);\r\n      window.removeEventListener(\"mousemove\", handleMouseMove);\r\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 pointer-events-none z-[9999] overflow-hidden\">\r\n      {/* SVG Filter for the Gooey Effect */}\r\n      <svg className=\"hidden\">\r\n        <defs>\r\n          <filter id=\"liquid-cursor-filter\">\r\n            <feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"10\" result=\"blur\" />\r\n            <feColorMatrix\r\n              in=\"blur\"\r\n              mode=\"matrix\"\r\n              values=\"1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7\"\r\n              result=\"goo\"\r\n            />\r\n            <feComposite in=\"SourceGraphic\" in2=\"goo\" operator=\"atop\" />\r\n          </filter>\r\n        </defs>\r\n      </svg>\r\n\r\n      <canvas\r\n        ref={canvasRef}\r\n        className=\"w-full h-full block\"\r\n        style={{ filter: \"url(#liquid-cursor-filter)\" }}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n",
      "type": "registry:ui",
      "target": "components/liquid-cursor"
    }
  ]
}